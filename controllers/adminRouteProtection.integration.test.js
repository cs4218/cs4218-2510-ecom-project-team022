// Important:
// This file has been generated by AI using Claude Sonnet 4.
// The prompt given was:
/**
 * Finish this file for all routes that make use of isAdmin
 *
 * Please check authRoutes.js, categoryRoutes.js, and productRoutes.js for admin auth
 *
 * It should for all:
 *
 * register new user
 * login new user
 * for each:
 * try to access the page and see that we are denied with 403
 */

// The file was then cleaned up afterwards, due to some incorrect assumptions made by the AI.

// TODO:
// update deleteController
// check if we need to test for non-admin cases
// figure out how to test for admin

import request from "supertest";
import { MongoMemoryServer } from "mongodb-memory-server";
import mongoose from "mongoose";
import express from "express";
import cors from "cors";
import morgan from "morgan";
import dotenv from "dotenv";

// Import routes and models
import authRoutes from "../routes/authRoute.js";
import categoryRoutes from "../routes/categoryRoutes.js";
import productRoutes from "../routes/productRoutes.js";
import userModel from "../models/userModel.js";
import categoryModel from "../models/categoryModel.js";
import productModel from "../models/productModel.js";

import * as authControllers from "../controllers/authController.js";

//recommended by AI to prevent errors during testing
jest.mock("braintree", () => ({
  BraintreeGateway: jest.fn().mockImplementation(() => ({
    transaction: {
      sale: jest.fn().mockResolvedValue({ success: true }),
    },
  })),
  Environment: { Sandbox: "sandbox" },
}));

// Configure environment
dotenv.config();

// Create Express app for testing
const createTestApp = () => {
  const app = express();

  // Middleware
  app.use(cors());
  app.use(express.json());
  app.use(morgan("dev"));

  // Routes
  app.use("/api/v1/auth", authRoutes);
  app.use("/api/v1/category", categoryRoutes);
  app.use("/api/v1/product", productRoutes);

  // special for admin
  app.use(
    "/api/v1/auth/register-admin",
    authControllers.registerAdminController
  );
  return app;
};

describe("Admin Route Protection Integration Tests - failure for non-admins", () => {
  let mongoServer;
  let app;
  let regularUserToken;
  let testCategory;
  let testProduct;

  beforeAll(async () => {
    // Start MongoDB Memory Server
    mongoServer = await MongoMemoryServer.create();
    const mongoUri = mongoServer.getUri();

    // Connect to in-memory database
    await mongoose.connect(mongoUri);

    // Create test app
    app = createTestApp();
  });

  afterAll(async () => {
    // Clean up
    await mongoose.disconnect();
    await mongoServer.stop();
  });

  beforeEach(async () => {
    // Clear all collections
    await userModel.deleteMany({});
    await categoryModel.deleteMany({});
    await productModel.deleteMany({});

    // 1. Register new regular user
    const registerRes = await request(app).post("/api/v1/auth/register").send({
      name: "Regular User",
      email: "regular@test.com",
      password: "password123",
      phone: "1234567890",
      address: "Test Address",
      answer: "test answer",
    });

    expect(registerRes.status).toBe(201);

    // 2. Login to get token
    const loginRes = await request(app).post("/api/v1/auth/login").send({
      email: "regular@test.com",
      password: "password123",
    });

    expect(loginRes.status).toBe(200);
    regularUserToken = loginRes.body.token;

    // Create test resources for update/delete operations
    testCategory = await categoryModel.create({
      name: "Test Category",
      slug: "test-category",
    });

    testProduct = await productModel.create({
      name: "Test Product",
      slug: "test-product",
      description: "Test Description",
      price: 100,
      category: testCategory._id,
      quantity: 10,
    });
  });

  // tests for admin protected routes in /auth
  describe("🔒 Auth Routes - Admin Protection", () => {
    const adminAuthRoutes = [
      {
        method: "get",
        path: "/api/v1/auth/test",
        description: "Test Route",
        expectedStatus: 403,
      },
      {
        method: "get",
        path: "/api/v1/auth/admin-auth",
        description: "Admin Auth Check",
        expectedStatus: 403,
      },
      {
        method: "get",
        path: "/api/v1/auth/all-orders",
        description: "Get All Orders",
        expectedStatus: 403,
      },
      {
        method: "put",
        path: `/api/v1/auth/order-status/${new mongoose.Types.ObjectId()}`,
        data: { status: "Processing" },
        description: "Update Order Status",
        expectedStatus: 403,
      },
    ];

    // false case
    adminAuthRoutes.forEach((route) => {
      test(`should deny regular user access to ${route.description}`, async () => {
        let requestBuilder = request(app)
          [route.method](route.path)
          .set("Authorization", `Bearer ${regularUserToken}`);

        if (route.data) {
          requestBuilder = requestBuilder.send(route.data);
        }

        const response = await requestBuilder;

        expect(response.status).toBe(route.expectedStatus);
        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain("Forbidden Access");
      });
    });

    // success case: TODO
  });

  // tests for admin protected routes in /category
  describe("🗂️ Category Routes - Admin Protection", () => {
    const adminCategoryRoutes = [
      {
        method: "post",
        path: "/api/v1/category/create-category",
        data: { name: "New Category" },
        description: "Create Category",
        expectedStatus: 403,
      },
      {
        method: "put",
        path: "/api/v1/category/update-category/:id",
        data: { name: "Updated Category" },
        description: "Update Category",
        expectedStatus: 403,
        useTestResource: true,
      },
      {
        method: "delete",
        path: "/api/v1/category/delete-category/:id",
        description: "Delete Category",
        expectedStatus: 403,
        useTestResource: true,
      },
    ];

    adminCategoryRoutes.forEach((route) => {
      test(`should deny regular user access to ${route.description}`, async () => {
        let testPath = route.path;

        if (route.useTestResource) {
          testPath = route.path.replace(":id", testCategory._id);
        }

        let requestBuilder = request(app)
          [route.method](testPath)
          .set("Authorization", `Bearer ${regularUserToken}`);

        if (route.data) {
          requestBuilder = requestBuilder.send(route.data);
        }

        const response = await requestBuilder;

        expect(response.status).toBe(route.expectedStatus);
        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain("Forbidden Access");
      });
    });

    // success case: TODO

    // Test public category routes should work for regular users
    // describe("✅ Public Category Routes (Should Work)", () => {
    //   test("should allow regular user to get all categories", async () => {
    //     const response = await request(app)
    //       .get("/api/v1/category/get-category")
    //       .set("Authorization", `Bearer ${regularUserToken}`);

    //     expect(response.status).toBe(200);
    //   });

    //   test("should allow regular user to get single category", async () => {
    //     const response = await request(app)
    //       .get(`/api/v1/category/single-category/${testCategory.slug}`)
    //       .set("Authorization", `Bearer ${regularUserToken}`);

    //     expect(response.status).toBe(200);
    //   });
    // });
  });

  // tests for admin protected routes in /product
  describe("📦 Product Routes - Admin Protection", () => {
    const adminProductRoutes = [
      {
        method: "post",
        path: "/api/v1/product/create-product",
        description: "Create Product",
        expectedStatus: 403,
        isFormData: true,
        data: {
          name: "New Product",
          description: "New Description",
          price: "150",
          quantity: "5",
        },
      },
      {
        method: "put",
        path: "/api/v1/product/update-product/:pid",
        description: "Update Product",
        expectedStatus: 403,
        useTestResource: true,
        isFormData: true,
        data: {
          name: "Updated Product",
          description: "Updated Description",
          price: "200",
        },
      },
    ];

    adminProductRoutes.forEach((route) => {
      test(`should deny regular user access to ${route.description}`, async () => {
        let testPath = route.path;

        if (route.useTestResource) {
          testPath = route.path.replace(":pid", testProduct._id);
        }

        let requestBuilder = request(app)
          [route.method](testPath)
          .set("Authorization", `Bearer ${regularUserToken}`);

        if (route.isFormData && route.data) {
          // Add category for product creation
          if (route.data.name) {
            requestBuilder = requestBuilder.field(
              "category",
              testCategory._id.toString()
            );
          }

          Object.keys(route.data).forEach((key) => {
            requestBuilder = requestBuilder.field(key, route.data[key]);
          });
        } else if (route.data) {
          requestBuilder = requestBuilder.send(route.data);
        }

        const response = await requestBuilder;

        expect(response.status).toBe(route.expectedStatus);
        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain("Forbidden Access");
      });
    });

    // Note: Delete product route doesn't have isAdmin middleware in the current setup
    // TODO: wait for zann to change
    test("should check if delete product route has proper protection", async () => {
      const response = await request(app)
        .delete(`/api/v1/product/delete-product/${testProduct._id}`)
        .set("Authorization", `Bearer ${regularUserToken}`);

      // This test will show if delete product route is properly protected
      // Based on current routes, it might not be protected
      console.log(`Delete product response status: ${response.status}`);
    });

    // Test public product routes should work for regular users
    // describe("✅ Public Product Routes (Should Work)", () => {
    //   test("should allow regular user to get all products", async () => {
    //     const response = await request(app)
    //       .get("/api/v1/product/get-product")
    //       .set("Authorization", `Bearer ${regularUserToken}`);

    //     expect(response.status).toBe(200);
    //   });

    //   test("should allow regular user to get single product", async () => {
    //     const response = await request(app)
    //       .get(`/api/v1/product/get-product/${testProduct.slug}`)
    //       .set("Authorization", `Bearer ${regularUserToken}`);

    //     expect(response.status).toBe(200);
    //   });

    //   test("should allow regular user to get product count", async () => {
    //     const response = await request(app)
    //       .get("/api/v1/product/product-count")
    //       .set("Authorization", `Bearer ${regularUserToken}`);

    //     expect(response.status).toBe(200);
    //   });

    //   test("should allow regular user to filter products", async () => {
    //     const response = await request(app)
    //       .post("/api/v1/product/product-filters")
    //       .set("Authorization", `Bearer ${regularUserToken}`)
    //       .send({ checked: [], radio: [] });

    //     expect(response.status).toBe(200);
    //   });

    //   test("should allow regular user to make payments", async () => {
    //     const response = await request(app)
    //       .post("/api/v1/product/braintree/payment")
    //       .set("Authorization", `Bearer ${regularUserToken}`)
    //       .send({
    //         nonce: "fake-valid-nonce",
    //         cart: [{ _id: testProduct._id, price: 100 }],
    //       });

    //     // This might fail due to Braintree setup, but should not be 403/403
    //     expect(response.status).not.toBe(403);
    //     expect(response.status).not.toBe(403);
    //   });
    // });
  });

  describe("🚫 Unauthenticated Access Tests", () => {
    const allAdminRoutes = [
      // Auth routes
      { method: "get", path: "/api/v1/auth/test" },
      { method: "get", path: "/api/v1/auth/admin-auth" },
      { method: "get", path: "/api/v1/auth/all-orders" },

      // Category routes
      {
        method: "post",
        path: "/api/v1/category/create-category",
        data: { name: "Test" },
      },
      {
        method: "put",
        path: `/api/v1/category/update-category/${new mongoose.Types.ObjectId()}`,
        data: { name: "Test" },
      },
      {
        method: "delete",
        path: `/api/v1/category/delete-category/${new mongoose.Types.ObjectId()}`,
      },

      // Product routes
      { method: "post", path: "/api/v1/product/create-product" },
      {
        method: "put",
        path: `/api/v1/product/update-product/${new mongoose.Types.ObjectId()}`,
      },
    ];

    allAdminRoutes.forEach((route) => {
      test(`should deny unauthenticated access to ${route.method.toUpperCase()} ${
        route.path
      }`, async () => {
        let requestBuilder = request(app)[route.method](route.path);

        if (route.data) {
          requestBuilder = requestBuilder.send(route.data);
        }

        const response = await requestBuilder;

        expect(response.status).toBe(401); // unauthenticated is 401! for logged in but not admin is 403
        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain("Unauthorized Access");
      });
    });
  });
});

describe("Admin Route Protection Integration Tests - success for admins", () => {
  let mongoServer;
  let app;
  let adminToken;
  let testCategory;
  let testProduct;
  let adminUserId;

  beforeAll(async () => {
    // Start MongoDB Memory Server
    mongoServer = await MongoMemoryServer.create();
    const mongoUri = mongoServer.getUri();

    // Connect to in-memory database
    await mongoose.connect(mongoUri);

    // Create test app
    app = createTestApp();
  });

  afterAll(async () => {
    // Clean up
    await mongoose.disconnect();
    await mongoServer.stop();
  });

  beforeEach(async () => {
    // Clear all collections
    await userModel.deleteMany({});
    await categoryModel.deleteMany({});
    await productModel.deleteMany({});

    // 1. Register new admin user
    const registerRes = await request(app)
      .post("/api/v1/auth/register-admin")
      .send({
        name: "Admin User",
        email: "admin@test.com",
        password: "password123",
        phone: "1234567890",
        address: "Test Address",
        answer: "test answer",
      });

    expect(registerRes.status).toBe(201);

    // 2. Login to get token
    const loginRes = await request(app).post("/api/v1/auth/login").send({
      email: "admin@test.com",
      password: "password123",
    });

    expect(loginRes.status).toBe(200);
    adminToken = loginRes.body.token;

    // Create test resources for update/delete operations
    testCategory = await categoryModel.create({
      name: "Test Category",
      slug: "test-category",
    });

    testProduct = await productModel.create({
      name: "Test Product",
      slug: "test-product",
      description: "Test Description",
      price: 100,
      category: testCategory._id,
      quantity: 10,
    });

    // Get admin user ID
    const adminUser = await userModel.findOne({ email: "admin@test.com" });
    adminUserId = adminUser._id;
  });

  describe("🔒 Auth Routes - Admin Success", () => {
    test("should allow admin access to test route", async () => {
      const response = await request(app)
        .get("/api/v1/auth/test")
        .set("Authorization", `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
    });

    test("should allow admin access to admin-auth route", async () => {
      const response = await request(app)
        .get("/api/v1/auth/admin-auth")
        .set("Authorization", `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty("ok", true);
    });

    test("should allow admin to get all orders", async () => {
      const response = await request(app)
        .get("/api/v1/auth/all-orders")
        .set("Authorization", `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
      // Should return empty array since no orders exist
      expect(Array.isArray(response.body)).toBe(true);
    });

    test("should allow admin to update order status", async () => {
      // Create a mock order first (you might need to create an order model instance)
      const orderId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .put(`/api/v1/auth/order-status/${orderId}`)
        .set("Authorization", `Bearer ${adminToken}`)
        .send({ status: "Processing" });

      // This might return 404 if order doesn't exist, but should not be 401/403
      expect(response.status).not.toBe(401);
      expect(response.status).not.toBe(403);
    });
  });

  describe("🗂️ Category Routes - Admin Success", () => {
    test("should allow admin to create category", async () => {
      const response = await request(app)
        .post("/api/v1/category/create-category")
        .set("Authorization", `Bearer ${adminToken}`)
        .send({ name: "Admin Created Category" });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.category.name).toBe("Admin Created Category");

      // Verify in database
      const createdCategory = await categoryModel.findOne({
        name: "Admin Created Category",
      });
      expect(createdCategory).toBeTruthy();
    });

    test("should allow admin to update category", async () => {
      const response = await request(app)
        .put(`/api/v1/category/update-category/${testCategory._id}`)
        .set("Authorization", `Bearer ${adminToken}`)
        .send({ name: "Updated Category Name" });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.category.name).toBe("Updated Category Name");

      // Verify in database
      const updatedCategory = await categoryModel.findById(testCategory._id);
      expect(updatedCategory.name).toBe("Updated Category Name");
    });

    test("should allow admin to delete category", async () => {
      const response = await request(app)
        .delete(`/api/v1/category/delete-category/${testCategory._id}`)
        .set("Authorization", `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);

      // Verify deletion in database
      const deletedCategory = await categoryModel.findById(testCategory._id);
      expect(deletedCategory).toBeNull();
    });
  });

  describe("📦 Product Routes - Admin Success", () => {
    test("should allow admin to create product", async () => {
      const response = await request(app)
        .post("/api/v1/product/create-product")
        .set("Authorization", `Bearer ${adminToken}`)
        .field("name", "Admin Created Product")
        .field("description", "Admin Created Description")
        .field("price", "299")
        .field("quantity", "15")
        .field("category", testCategory._id.toString());

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);

      // Verify in database
      const createdProduct = await productModel.findOne({
        name: "Admin Created Product",
      });
      expect(createdProduct).toBeTruthy();
      expect(createdProduct.price).toBe(299);
    });

    test("should allow admin to update product", async () => {
      const response = await request(app)
        .put(`/api/v1/product/update-product/${testProduct._id}`)
        .set("Authorization", `Bearer ${adminToken}`)
        .field("name", "Updated Product Name")
        .field("description", "Updated Product Description")
        .field("price", "399")
        .field("category", testCategory._id.toString())
        .field("quantity", "20");

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);

      // Verify in database
      const updatedProduct = await productModel.findById(testProduct._id);
      expect(updatedProduct.name).toBe("Updated Product Name");
      expect(updatedProduct.price).toBe(399);
    });
  });

  describe("✅ Complete Admin Workflow Tests", () => {
    test("should allow admin to perform complete CRUD operations", async () => {
      // CREATE Category
      const createCategoryRes = await request(app)
        .post("/api/v1/category/create-category")
        .set("Authorization", `Bearer ${adminToken}`)
        .send({ name: "Workflow Category" });

      expect(createCategoryRes.status).toBe(201);
      const categoryId = createCategoryRes.body.category._id;

      // CREATE Product
      const createProductRes = await request(app)
        .post("/api/v1/product/create-product")
        .set("Authorization", `Bearer ${adminToken}`)
        .field("name", "Workflow Product")
        .field("description", "Workflow Description")
        .field("price", "199")
        .field("quantity", "10")
        .field("category", categoryId);

      expect(createProductRes.status).toBe(201);
      console.log(createProductRes.body);
      const productId = createProductRes.body.product._id;

      // UPDATE Product
      const updateProductRes = await request(app)
        .put(`/api/v1/product/update-product/${productId}`)
        .set("Authorization", `Bearer ${adminToken}`)
        .field("name", "Updated Workflow Product")
        .field("description", "Updated Workflow Description")
        .field("price", "249")
        .field("category", categoryId)
        .field("quantity", "15");

      expect(updateProductRes.status).toBe(200);

      // UPDATE Category
      const updateCategoryRes = await request(app)
        .put(`/api/v1/category/update-category/${categoryId}`)
        .set("Authorization", `Bearer ${adminToken}`)
        .send({ name: "Updated Workflow Category" });

      expect(updateCategoryRes.status).toBe(200);

      // DELETE Category
      const deleteCategoryRes = await request(app)
        .delete(`/api/v1/category/delete-category/${categoryId}`)
        .set("Authorization", `Bearer ${adminToken}`);

      expect(deleteCategoryRes.status).toBe(200);

      // Verify all operations worked
      const finalCategory = await categoryModel.findById(categoryId);
      const finalProduct = await productModel.findById(productId);

      expect(finalCategory).toBeNull(); // Category should be deleted
      expect(finalProduct.name).toBe("Updated Workflow Product"); // Product should be updated
    });
  });

  describe("🔍 Admin Permission Verification", () => {
    test("should verify admin user has correct role in database", async () => {
      const user = await userModel.findById(adminUserId);
      expect(user.role).toBe(1);
    });

    test("should verify admin token is valid and contains correct user ID", async () => {
      const response = await request(app)
        .get("/api/v1/auth/admin-auth")
        .set("Authorization", `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
      expect(response.body.ok).toBe(true);
    });
  });
});
