// This file was generated by AI.
// the prompt used:
// Write unit tests for these:

// correct display of data fetched from backend (mock)
// --> success case
// --> error case: show toast
// requests for and inserts all possible categories into the dom
// success & error
// update product
// success and error, and thrown error
// delte product
// make sure a window.prompt is shown
// make sure if no answer, we do not call delete
// scucess and error, and thrown error

import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import UpdateProduct from "./UpdateProduct";
import axios from "axios";
import toast from "react-hot-toast";
import { MemoryRouter, useNavigate, useParams } from "react-router-dom";

// Mock URL.createObjectURL for file upload tests
global.URL.createObjectURL = jest.fn(() => "mocked-object-url");
global.URL.revokeObjectURL = jest.fn();

// Mock window.prompt
global.window.prompt = jest.fn();

jest.mock("axios");
jest.mock("react-hot-toast");
jest.mock("react-router-dom", () => ({
  ...jest.requireActual("react-router-dom"),
  useNavigate: jest.fn(),
  useParams: jest.fn(),
}));

var mockUseAuth = jest.fn();
jest.mock("../../context/auth", () => ({
  useAuth: () => mockUseAuth(),
}));

jest.mock("../../components/Layout", () => ({ children }) => (
  <div>{children}</div>
));

jest.mock("../../components/AdminMenu", () => () => <div>Admin Menu</div>);

describe("UpdateProduct", () => {
  let mockNavigate;

  const mockProduct = {
    _id: "product123",
    name: "Test Product",
    description: "Test Description",
    price: 100,
    quantity: 10,
    shipping: true,
    category: { _id: "cat123", name: "Test Category" },
  };

  const mockCategories = [
    { _id: "cat123", name: "Test Category" },
    { _id: "cat456", name: "Another Category" },
  ];

  const renderUpdateProduct = () => {
    return render(
      <MemoryRouter
        initialEntries={["/dashboard/admin/update-product/test-slug"]}
      >
        <UpdateProduct />
      </MemoryRouter>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockNavigate = jest.fn();
    useNavigate.mockReturnValue(mockNavigate);
    useParams.mockReturnValue({ slug: "test-slug" });

    // Reset window.prompt mock
    global.window.prompt.mockReset();
  });

  describe("1. Product Data Fetching and Display", () => {
    it("fetches and displays product data successfully", async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.resolve({ data: { product: mockProduct } });
        }
        if (url.includes("get-category")) {
          return Promise.resolve({
            data: { success: true, category: mockCategories },
          });
        }
      });

      renderUpdateProduct();

      // Wait for product data to load and populate form fields
      await waitFor(() => {
        expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument();
        expect(
          screen.getByDisplayValue("Test Description")
        ).toBeInTheDocument();
        expect(screen.getByDisplayValue("100")).toBeInTheDocument();
        expect(screen.getByDisplayValue("10")).toBeInTheDocument();
      });

      expect(axios.get).toHaveBeenCalledWith(
        "/api/v1/product/get-product/test-slug"
      );
    });

    it("shows error toast when product fetching fails", async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.reject(new Error("Network error"));
        }
        if (url.includes("get-category")) {
          return Promise.resolve({
            data: { success: true, category: mockCategories },
          });
        }
      });

      renderUpdateProduct();

      await waitFor(() => {
        expect(toast.error).toHaveBeenCalledWith(
          "Something went wrong in getting product"
        );
      });
    });
  });

  describe("2. Categories Fetching and Display", () => {
    it("fetches categories successfully and inserts them into DOM", async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.resolve({ data: { product: mockProduct } });
        }
        if (url.includes("get-category")) {
          return Promise.resolve({
            data: { success: true, category: mockCategories },
          });
        }
      });

      renderUpdateProduct();

      await waitFor(() => {
        expect(axios.get).toHaveBeenCalledWith("/api/v1/category/get-category");
      });

      // Note: Antd Select options are rendered virtually, so we check if the component rendered without errors
      // and that the axios call was made
      expect(screen.getByText("Update Product")).toBeInTheDocument();
    });

    it("shows error toast when category fetching fails", async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.resolve({ data: { product: mockProduct } });
        }
        if (url.includes("get-category")) {
          return Promise.reject(new Error("Category fetch failed"));
        }
      });

      renderUpdateProduct();

      await waitFor(() => {
        expect(toast.error).toHaveBeenCalledWith(
          "Something went wrong in getting category"
        );
      });
    });
  });

  describe("3. Update Product", () => {
    beforeEach(async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.resolve({ data: { product: mockProduct } });
        }
        if (url.includes("get-category")) {
          return Promise.resolve({
            data: { success: true, category: mockCategories },
          });
        }
      });

      renderUpdateProduct();

      // Wait for initial data to load
      await waitFor(() => {
        expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument();
      });
    });

    it("updates product successfully", async () => {
      axios.put.mockResolvedValueOnce({
        data: { success: true },
      });

      // Update the product name
      const nameInput = screen.getByDisplayValue("Test Product");
      fireEvent.change(nameInput, { target: { value: "Updated Product" } });

      // Click update button
      const updateButton = document.getElementById("update-product-btn");
      fireEvent.click(updateButton);

      await waitFor(() => {
        expect(axios.put).toHaveBeenCalledWith(
          "/api/v1/product/update-product/product123",
          expect.any(FormData)
        );
        expect(toast.success).toHaveBeenCalledWith(
          "Product Updated Successfully"
        );
        expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
      });
    });

    it("shows error message when update fails with error response", async () => {
      const errorMessage = "Update failed";
      axios.put.mockResolvedValueOnce({
        data: { success: false, message: errorMessage },
      });

      const updateButton = document.getElementById("update-product-btn");
      fireEvent.click(updateButton);

      await waitFor(() => {
        expect(axios.put).toHaveBeenCalled();
        expect(toast.error).toHaveBeenCalledWith(errorMessage);
        expect(mockNavigate).not.toHaveBeenCalled();
      });
    });

    it("shows generic error when update throws exception", async () => {
      axios.put.mockRejectedValueOnce(new Error("Network error"));

      const updateButton = document.getElementById("update-product-btn");
      fireEvent.click(updateButton);

      await waitFor(() => {
        expect(axios.put).toHaveBeenCalled();
        expect(toast.error).toHaveBeenCalledWith("something went wrong");
        expect(mockNavigate).not.toHaveBeenCalled();
      });
    });
  });

  describe("4. Delete Product", () => {
    beforeEach(async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.resolve({ data: { product: mockProduct } });
        }
        if (url.includes("get-category")) {
          return Promise.resolve({
            data: { success: true, category: mockCategories },
          });
        }
      });

      renderUpdateProduct();

      // Wait for initial data to load
      await waitFor(() => {
        expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument();
      });
    });

    it("shows window.prompt when delete button is clicked", async () => {
      global.window.prompt.mockReturnValue("yes");
      axios.delete.mockResolvedValueOnce({ data: { success: true } });

      const deleteButton = document.getElementById("delete-product-btn");
      fireEvent.click(deleteButton);

      expect(global.window.prompt).toHaveBeenCalledWith(
        "Are You Sure want to delete this product ? "
      );
    });

    it("does not call delete API when user cancels prompt", async () => {
      global.window.prompt.mockReturnValue(""); // User cancels or enters empty string

      const deleteButton = document.getElementById("delete-product-btn");
      fireEvent.click(deleteButton);

      expect(global.window.prompt).toHaveBeenCalled();
      expect(axios.delete).not.toHaveBeenCalled();
      expect(toast.success).not.toHaveBeenCalled();
      expect(mockNavigate).not.toHaveBeenCalled();
    });

    it("does not call delete API when user returns null (cancels)", async () => {
      global.window.prompt.mockReturnValue(null); // User cancels

      const deleteButton = document.getElementById("delete-product-btn");
      fireEvent.click(deleteButton);

      expect(global.window.prompt).toHaveBeenCalled();
      expect(axios.delete).not.toHaveBeenCalled();
      expect(toast.success).not.toHaveBeenCalled();
      expect(mockNavigate).not.toHaveBeenCalled();
    });

    it("deletes product successfully when user confirms", async () => {
      global.window.prompt.mockReturnValue("yes");
      axios.delete.mockResolvedValueOnce({ data: { success: true } });

      const deleteButton = document.getElementById("delete-product-btn");
      fireEvent.click(deleteButton);

      await waitFor(() => {
        expect(axios.delete).toHaveBeenCalledWith(
          "/api/v1/product/delete-product/product123"
        );
        expect(toast.success).toHaveBeenCalledWith(
          "Product Deleted Successfully"
        );
        expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
      });
    });

    it("shows error when delete throws exception", async () => {
      global.window.prompt.mockReturnValue("yes");
      axios.delete.mockRejectedValueOnce(new Error("Delete failed"));

      const deleteButton = document.getElementById("delete-product-btn");
      fireEvent.click(deleteButton);

      await waitFor(() => {
        expect(axios.delete).toHaveBeenCalled();
        expect(toast.error).toHaveBeenCalledWith("Something went wrong");
        expect(mockNavigate).not.toHaveBeenCalled();
      });
    });
  });

  describe("5. Photo Upload", () => {
    beforeEach(async () => {
      axios.get.mockImplementation((url) => {
        if (url.includes("get-product")) {
          return Promise.resolve({ data: { product: mockProduct } });
        }
        if (url.includes("get-category")) {
          return Promise.resolve({
            data: { success: true, category: mockCategories },
          });
        }
      });

      renderUpdateProduct();

      await waitFor(() => {
        expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument();
      });
    });

    it("displays uploaded photo name and shows preview", async () => {
      // Initially should show "Upload Photo"
      expect(screen.getByText("Upload Photo")).toBeInTheDocument();

      // Create a mock file
      const mockFile = new File(["test content"], "new-photo.jpg", {
        type: "image/jpeg",
      });

      // Find the file input and upload the file
      const fileInput = document.querySelector('input[type="file"]');
      fireEvent.change(fileInput, {
        target: { files: [mockFile] },
      });

      // Wait for the photo name to be displayed
      await waitFor(() => {
        expect(screen.getByText("new-photo.jpg")).toBeInTheDocument();
      });

      // Verify "Upload Photo" is no longer shown
      expect(screen.queryByText("Upload Photo")).not.toBeInTheDocument();
    });
  });
});
